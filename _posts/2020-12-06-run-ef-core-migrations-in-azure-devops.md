---
layout: post
title: "Run EF Core Migrations in Azure DevOps"
subtitle: "This post is about running Entity Framework Core migrations on Azure DevOps which helps you to continuously deploy your database changes to your staging or your QA environments."
date: 2020-12-06 00:00:00
categories: [Azure,DevOps,EFCore]
tags: [Azure,DevOps,EFCore]
author: "Anuraj"
image: /assets/images/2020/12/build_pipeline.png
---
This post is about running Entity Framework Core migrations on Azure DevOps which helps you to continuously deploy your database changes to your staging or your QA environments or even to production - even though I won't recommend it. We will be using Entity Framework Core Code first approach. 

For this blog post I am using an Web API application - a todo list - which is using SQL Server as backend. I am creating EF core migrations and committing them to source control - which is important - in this case GitHub. I am building the SQL Scripts from EF Core migrations code which is committed in source control. And as part of Release pipeline I am executing them in the Azure SQL Server.

Here is my build pipeline looks like.

![Azure DevOps Build Pipeline]({{ site.url }}/assets/images/2020/12/build_pipeline.png)

It is normal .NET Core build pipeline, but I have added few more steps to build and generate EF Core migrations.

1. Create Manifest file - This is again a dotnet command which will help you to create a manifest file using the `dotnet new tool-manifest` command. This is required because I am installing the `dotnet ef` command locally instead of installing it globally.

2. Install EF tool - This command install the `dotnet ef` tool locally, so that I can build the SQL Script from migrations script. This is step is using the `dotnet  tool install dotnet-ef`.

3. Create SQL Scripts - This step will generate SQL scripts using `dotnet ef` command with the following command - `dotnet ef migrations script --output $(Build.SourcesDirectory)/SQL/tododbscript.sql --idempotent --project $(Build.SourcesDirectory)/src/TodoApi.csproj --context TodoApiDbContext`. In this command the `--idempotent` parameter is important. Otherwise it might not work the way it is expected.

4. Publish Artifacts : SQL Scripts - This step will publish the SQL Scripts as artifacts generated by the `Create SQL Scripts` step.

Here is the complete YAML script.

{% highlight YAML %}
steps:
- checkout: self
- task: DotNetCoreCLI@2
  displayName: New Manifest for tool
  inputs:
    command: custom
    custom: 'new '
    arguments: tool-manifest
- task: DotNetCoreCLI@2
  displayName: Install EF Tool
  inputs:
    command: custom
    custom: 'tool '
    arguments: install dotnet-ef
- task: DotNetCoreCLI@2
  displayName: Restore
  inputs:
    command: restore
    projects: $(BuildParameters.RestoreBuildProjects)
- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    projects: $(BuildParameters.RestoreBuildProjects)
    arguments: --configuration $(BuildConfiguration)
- task: DotNetCoreCLI@2
  displayName: Create SQL Scripts
  inputs:
    command: custom
    custom: 'ef '
    arguments: migrations script --output $(Build.SourcesDirectory)/SQL/tododbscript.sql --idempotent --project $(Build.SourcesDirectory)/src/TodoApi.csproj --context TodoApiDbContext
- task: DotNetCoreCLI@2
  displayName: Publish
  inputs:
    command: publish
    publishWebProjects: True
    projects: $(BuildParameters.RestoreBuildProjects)
    arguments: --configuration $(BuildConfiguration) --output $(build.artifactstagingdirectory)
    zipAfterPublish: True
- task: PublishBuildArtifacts@1
  displayName: Publish Artifact
  condition: succeededOrFailed()
  inputs:
    PathtoPublish: $(build.artifactstagingdirectory)
    TargetPath: '\\my\share\$(Build.DefinitionName)\$(Build.BuildNumber)'
- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact: SQLScripts'
  inputs:
    PathtoPublish: $(Build.SourcesDirectory)/SQL/tododbscript.sql
    ArtifactName: SQLScripts
{% endhighlight %}

This script will create two artifacts - the drop zip file and SQL Script file.

![Azure DevOps Generated Artifacts]({{ site.url }}/assets/images/2020/12/generated_artifacts.png)

Next I created a Release pipeline which take this artifacts and deploy it Azure Web App and SQL Server. This step is optional, you can deploy it along with build pipeline. But it is recommended to use Release pipeline, so that we can control the number of deployments to the environments.

![Azure DevOps Release pipeline]({{ site.url }}/assets/images/2020/12/release_pipeline.png)

First step will deploy the `drop` folder to web app using Web Deploy. Second I am adding `Azure SQL Database deployment` task. In which I am configuring authentication mode which is SQL Server, username, password and database. And select Deploy type as `SQL Script File` and select the SQL Script file - `$(Build.SourcesDirectory)/SQL/tododbscript.sql`.

You can configure the trigger to deploy it when a build completes or you can manually do it. Here is the Release pipeline completed.

![Azure DevOps Release pipeline completed]({{ site.url }}/assets/images/2020/12/release_pipeline2.png)

This way you can configure your application database deployment using Azure DevOps and Entity Framework Core migrations - you need to make sure you're committing the migration scripts to source control. Unlike running dotnet ef database update command - the script command won't create the Databases. You need to create an empty database and configure it in the SQL Task in release pipeline.

Happy Programming :)